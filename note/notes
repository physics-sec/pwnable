the "note" binary will be executed under note_pwn privilege if you connect to port 9019.
execute the binary by connecting to daemon(nc 0 9019) then pwn it, then get flag.
* ASLR is disabled for this challenge



Partial RELRO   No canary found   NX enabled    No PIE



1 byte overflow en case secreto

overflow en todas las notas

podes leer y escribir la nota 256, la cual no se inicializa

mem_arr[257] -> no 256

plan
1) crear notas de la 0 a la 255
2) intentar leer o escribir la 256 



https://stackoverflow.com/questions/28575893/when-would-one-use-mmap-map-fixed
Further, note that use of MAP_FIXED with a hard-coded address or a random address is always a bug. The only correct way to use MAP_FIXED is to replace an existing mapping whose address was assigned by a previous successful call to mmap without MAP_FIXED, or in some other way where you feel it's safe to replace whole pages. This aspect too is completely analogous to dup2; it's always a bug to use dup2 when the caller doesn't already have an open file on the target fd with the intent to replace it.



       MAP_FIXED
              Don't  interpret  addr  as  a hint: place the mapping at exactly
              that address.  addr must be suitably aligned: for most architec‐
              tures  a  multiple of the page size is sufficient; however, some
              architectures may impose additional restrictions.  If the memory
              region  specified by addr and len overlaps pages of any existing
              mapping(s), then the overlapped part of the existing  mapping(s)
              will  be  discarded.   If  the specified address cannot be used,
              mmap() will fail.

              Software that aspires to be portable should  use  the  MAP_FIXED
              flag  with  care,  keeping  in  mind  that the exact layout of a
              process's memory mappings is allowed to change significantly be‐
              tween  kernel versions, C library versions, and operating system
              releases.  Carefully read the discussion of this flag in NOTES!
RETURN VALUE
       On success, mmap() returns a pointer to the mapped area.  On error, the
       value  MAP_FAILED  (that is, (void *) -1) is returned, and errno is set
       to indicate the cause of the error.

       On success, munmap() returns 0.  On failure, it returns -1,  and  errno
       is set to indicate the cause of the error (probably to EINVAL).



Las notas tienen los permisos: PROT_READ|PROT_WRITE|PROT_EXEC
si redirijo la ejecucion de código a una página -> win()

yo se la direccion de memoria de todas las notas,
y puedo sobreescribir un byte del Case hacker




command: ebp-0x40c
0x40c = 1036
no alcanza, buffer: 1025

ebp-0xc
0xc = 12

command pisa hasta ebp-0xb (-11)

es decir, pisa un byte de la variable, cual variable? -> es el indice del menu elegido...




idea general -> redireccionar la ejecucion de código a cualquiera de las notas, habiendo hubicado shellcode ahi.
como redirecciono la ejecucion de codigo?
1) crear muchas notas hasta que una este encima de algo interesante
2) explotar el buffer overflow de la nota y sobre escribir whatever
3) redireccionar codigo a la nota con shellcode
4) leer flag =D


obj.mem_arr[257]  ->  0x0804b0a0

addr = (void*)( ((int)addr & 0xFFFFF000) | 0x80000000 );
por como se contruye mi addr, no puedo nunca pisar el programa o el heap

se onde está todo!


gdb en pwnable.kr:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x804a000     0x2000        0x0 /home/note/note
	 0x804a000  0x804b000     0x1000     0x1000 /home/note/note
	 0x804b000  0x804c000     0x1000     0x2000 /home/note/note
	0xf7e11000 0xf7e12000     0x1000        0x0 
	0xf7e12000 0xf7fc2000   0x1b0000        0x0 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fc2000 0xf7fc4000     0x2000   0x1af000 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fc4000 0xf7fc5000     0x1000   0x1b1000 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fc5000 0xf7fc8000     0x3000        0x0 
	0xf7fd4000 0xf7fd5000     0x1000        0x0 
	0xf7fd5000 0xf7fd7000     0x2000        0x0 [vvar]
	0xf7fd7000 0xf7fd9000     0x2000        0x0 [vdso]
	0xf7fd9000 0xf7ffc000    0x23000        0x0 /lib/i386-linux-gnu/ld-2.23.so
	0xf7ffc000 0xf7ffd000     0x1000    0x22000 /lib/i386-linux-gnu/ld-2.23.so
	0xf7ffd000 0xf7ffe000     0x1000    0x23000 /lib/i386-linux-gnu/ld-2.23.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]


